# Вариант 1

Вам необходимо разработать базу данных для небольшой системы управления проектами. Система должна хранить информацию о сотрудниках, проектах, над которыми они работают, и конкретных задачах в рамках этих проектов.

**Структура данных должна состоять из трех таблиц:**

1.  `Projects` (Проекты): хранит информацию о проектах.
2.  `Employees` (Сотрудники): содержит данные о сотрудниках компании.
3.  `Tasks` (Задачи): основная таблица, связывающая проекты и сотрудников с конкретными задачами. Каждая задача относится к одному проекту и назначается одному сотруднику.

## Задание 1. Проектирование и реализация (10 баллов)

**Цель:** Продемонстрировать навыки проектирования реляционной базы данных, понимание принципов нормализации и владение языком DDL (Data Definition Language).

**Действия:**

1.  **Создайте ER-диаграмму** для описанной выше системы из трех таблиц (`Projects`, `Employees`, `Tasks`). Определите:
    *   Все необходимые атрибуты для каждой таблицы (например, `project_id`, `project_name`, `deadline` для `Projects`).
    *   Типы данных для каждого атрибута.
    *   Первичные ключи (`PRIMARY KEY`) для каждой таблицы.
    *   Внешние ключи (`FOREIGN KEY`) для установления связей между таблицами.

2.  **Напишите SQL-скрипт (`CREATE TABLE`)** для создания этих трех таблиц в любой реляционной СУБД (например, PostgreSQL или MySQL). Скрипт должен включать:
    *   Определение всех столбцов с корректными типами данных.
    *   Назначение первичных и внешних ключей.
    *   Использование ограничений `NOT NULL` для обязательных полей (например, название проекта или задачи).
    *   Добавление ограничения `DEFAULT` для статуса задачи (например, `DEFAULT 'new'`).

3.  **Письменно обоснуйте**, почему ваша схема находится в **третьей нормальной форме (3NF)**. Кратко объясните, как вы избежали аномалий данных, обеспечив отсутствие транзитивных и частичных зависимостей.

## Задание 2. Работа с данными и сложные запросы (10 баллов)

**Цель:** Продемонстрировать владение языком SQL для извлечения и анализа данных, включая объединение таблиц и агрегацию.

**Действия:**

1.  Напишите и выполните SQL-скрипт для **наполнения таблиц тестовыми данными** (минимум 2 проекта, 4 сотрудника, 10-12 задач).
2.  **Напишите следующие SQL-запросы:**
    *   **Простой `SELECT`:** Вывести все проекты, дедлайн которых наступает в следующем месяце.
    *   **`UPDATE`:** Изменить статус одной из задач на "in_progress" и переназначить ее другому сотруднику.
    *   **`SELECT` с `INNER JOIN`:** Вывести список всех задач со статусом "new", указав название задачи, название проекта и ФИО исполнителя.
    *   **`SELECT` с `LEFT JOIN`:** Вывести список **всех** сотрудников и количество назначенных на них активных (`'new'` или `'in_progress'`) задач. Сотрудники без задач также должны попасть в выборку (с 0 задач).
    *   **`SELECT` с `GROUP BY` и `HAVING`:** Найти проекты, в которых средний срок выполнения задачи (предположим, у задач есть поля `start_date` и `end_date`) превышает 10 дней.
    *   **Сложный запрос:** Вывести имя сотрудника, который назначен на наибольшее количество задач.

## Задание 3. Оптимизация и анализ схемы (10 баллов)

**Цель.** Продемонстрировать понимание основ оптимизации запросов, умение работать с индексами и инструментами анализа СУБД.

**Действия:**

1.  **Анализ запроса:** Напишите запрос для поиска всех задач по части их описания (предположим, у таблицы `Tasks` есть текстовое поле `description`).
    ```sql
    SELECT * FROM Tasks WHERE description LIKE '%срочный отчет%';
    ```
    Выполните команду `EXPLAIN` (или `EXPLAIN ANALYZE`) для этого запроса. Вставьте результат в отчет и **письменно объясните**, почему этот запрос неэффективен (укажите на `Full Table Scan` или аналогичную операцию).

2.  **Создание индекса:** Предложите и создайте индекс, который мог бы ускорить похожие запросы (например, если бы мы искали по точному значению или с начала строки). Напишите `CREATE INDEX` команду.
    *Примечание: Индекс для `LIKE '%...'` обычно не используется, но здесь важно продемонстрировать понимание того, для чего индексы создаются.*

3.  **Реверс-инжиниринг:** Используя любой инструмент (DBeaver, DataGrip и т.д.), сгенерируйте диаграмму на основе созданной вами в СУБД базы данных.
4.  **Сравнение:** Сравните полученную схему с вашей ER-диаграммой из Задания 1. Опишите, есть ли между ними отличия и почему они могли возникнуть (например, в отображении типов данных, названий ограничений и т.д.).

---

## Критерии оценки (Всего: 30 баллов)

| № | Задание | Критерий | Макс. балл |
|---|---|---|---|
| **1** | **Проектирование и реализация** | | **10** |
| 1.1 | ER-диаграмма корректна: все сущности, атрибуты, ключи и связи определены верно. | 4 |
| 1.2 | SQL DDL-скрипт написан без ошибок, использует все требуемые ограничения. | 4 |
| 1.3 | Дано четкое и правильное обоснование соответствия схемы третьей нормальной форме. | 2 |
| **2** | **Работа с данными и сложные запросы** | | **10** |
| 2.1 | Таблицы корректно наполнены данными. | 1 |
| 2.2 | Все 6 SQL-запросов написаны корректно и возвращают правильный результат. | 9 (по 1.5 за запрос) |
| **3** | **Оптимизация и анализ схемы** | | **10** |
| 3.1 | Выполнен `EXPLAIN`, результат проанализирован, дан верный вывод о неэффективности. | 4 |
| 3.2 | Предложен и создан синтаксически верный индекс. | 2 |
| 3.3 | Выполнен реверс-инжиниринг, предоставлена сгенерированная схема. | 2 |
| 3.4 | Проведен грамотный сравнительный анализ исходной и сгенерированной схем. | 2 |
